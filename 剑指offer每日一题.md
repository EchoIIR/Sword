
- [剑指offer练习题](#%e5%89%91%e6%8c%87offer%e7%bb%83%e4%b9%a0%e9%a2%98)
  - [说明：](#%e8%af%b4%e6%98%8e)
  - [一. 数组](#%e4%b8%80-%e6%95%b0%e7%bb%84)
    - [T1. 二维数组中的查找（M4.P44）](#t1-%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9f%a5%e6%89%bem4p44)
      - [考点：](#%e8%80%83%e7%82%b9)
      - [思路：](#%e6%80%9d%e8%b7%af)
      - [难点：](#%e9%9a%be%e7%82%b9)
      - [技巧：](#%e6%8a%80%e5%b7%a7)
      - [代码实现：](#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0)
  - [二. 字符串](#%e4%ba%8c-%e5%ad%97%e7%ac%a6%e4%b8%b2)
    - [T2. 替换空格（M5.P51）](#t2-%e6%9b%bf%e6%8d%a2%e7%a9%ba%e6%a0%bcm5p51)
      - [考点：](#%e8%80%83%e7%82%b9-1)
      - [思路：](#%e6%80%9d%e8%b7%af-1)
      - [难点：](#%e9%9a%be%e7%82%b9-1)
      - [技巧:](#%e6%8a%80%e5%b7%a7)
      - [思考：](#%e6%80%9d%e8%80%83)
  - [三. 链表](#%e4%b8%89-%e9%93%be%e8%a1%a8)
    - [T3. 二维数组中的查找（M6.P58）](#t3-%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9f%a5%e6%89%bem6p58)
      - [考点：](#%e8%80%83%e7%82%b9-2)
      - [思路：](#%e6%80%9d%e8%b7%af-2)
      - [难点：](#%e9%9a%be%e7%82%b9-2)
      - [技巧：](#%e6%8a%80%e5%b7%a7-1)
      - [思考：](#%e6%80%9d%e8%80%83-1)
  - [四. 树](#%e5%9b%9b-%e6%a0%91)
    - [T4. 重建二叉树（M7.P62）](#t4-%e9%87%8d%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91m7p62)
      - [考点：](#%e8%80%83%e7%82%b9-3)
      - [思路：](#%e6%80%9d%e8%b7%af-3)
      - [难点：](#%e9%9a%be%e7%82%b9-3)
      - [技巧：](#%e6%8a%80%e5%b7%a7-2)
      - [思考：](#%e6%80%9d%e8%80%83-2)
  - [五. 栈和队列](#%e4%ba%94-%e6%a0%88%e5%92%8c%e9%98%9f%e5%88%97)
    - [T5. 用两个栈实现队列（M9.P68）](#t5-%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97m9p68)
      - [考点：](#%e8%80%83%e7%82%b9-4)
      - [思路：](#%e6%80%9d%e8%b7%af-4)
      - [难点：](#%e9%9a%be%e7%82%b9-4)
      - [技巧：](#%e6%8a%80%e5%b7%a7-3)
      - [思考：](#%e6%80%9d%e8%80%83-3)
  - [六. 查找和排序](#%e5%85%ad-%e6%9f%a5%e6%89%be%e5%92%8c%e6%8e%92%e5%ba%8f)
    - [T6. 旋转数组的最小数字（M11.P82）](#t6-%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%b0%8f%e6%95%b0%e5%ad%97m11p82)
      - [考点：](#%e8%80%83%e7%82%b9-5)
      - [思路：](#%e6%80%9d%e8%b7%af-5)
      - [难点：](#%e9%9a%be%e7%82%b9-5)
      - [技巧：](#%e6%8a%80%e5%b7%a7-4)
      - [思考：](#%e6%80%9d%e8%80%83-4)
  - [七. 递归和循环](#%e4%b8%83-%e9%80%92%e5%bd%92%e5%92%8c%e5%be%aa%e7%8e%af)
    - [T7. 斐波拉切数列（M10.P74）](#t7-%e6%96%90%e6%b3%a2%e6%8b%89%e5%88%87%e6%95%b0%e5%88%97m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-6)
      - [思路：](#%e6%80%9d%e8%b7%af-6)
      - [难点：](#%e9%9a%be%e7%82%b9-6)
      - [技巧：](#%e6%8a%80%e5%b7%a7-5)
      - [思考：](#%e6%80%9d%e8%80%83-5)
    - [T8. 跳台阶（M10.P74）](#t8-%e8%b7%b3%e5%8f%b0%e9%98%b6m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-7)
      - [思路：](#%e6%80%9d%e8%b7%af-7)
      - [难点：](#%e9%9a%be%e7%82%b9-7)
      - [技巧：](#%e6%8a%80%e5%b7%a7-6)
      - [思考：](#%e6%80%9d%e8%80%83-6)
    - [T9. 变态跳台阶（M10.P74）](#t9-%e5%8f%98%e6%80%81%e8%b7%b3%e5%8f%b0%e9%98%b6m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-8)
      - [思路：](#%e6%80%9d%e8%b7%af-8)
      - [难点：](#%e9%9a%be%e7%82%b9-8)
      - [技巧：](#%e6%8a%80%e5%b7%a7-7)
      - [思考：](#%e6%80%9d%e8%80%83-7)
    - [T10. 矩形覆盖（M10.P74）](#t10-%e7%9f%a9%e5%bd%a2%e8%a6%86%e7%9b%96m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-9)
      - [思路：](#%e6%80%9d%e8%b7%af-9)
      - [难点：](#%e9%9a%be%e7%82%b9-9)
      - [技巧：](#%e6%8a%80%e5%b7%a7-8)
      - [思考：](#%e6%80%9d%e8%80%83-8)
  - [八. 位运算](#%e5%85%ab-%e4%bd%8d%e8%bf%90%e7%ae%97)
    - [T11. 二进制中1的个数（M15.P100）](#t11-%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%b8%ad1%e7%9a%84%e4%b8%aa%e6%95%b0m15p100)
      - [考点：](#%e8%80%83%e7%82%b9-10)
      - [思路：](#%e6%80%9d%e8%b7%af-10)
      - [难点：](#%e9%9a%be%e7%82%b9-10)
      - [技巧：](#%e6%8a%80%e5%b7%a7-9)
      - [思考：](#%e6%80%9d%e8%80%83-9)
  - [九. 代码的完整性](#%e4%b9%9d-%e4%bb%a3%e7%a0%81%e7%9a%84%e5%ae%8c%e6%95%b4%e6%80%a7)
    - [T12. 数值的整数次方（M16.P110）](#t12-%e6%95%b0%e5%80%bc%e7%9a%84%e6%95%b4%e6%95%b0%e6%ac%a1%e6%96%b9m16p110)
      - [考点：](#%e8%80%83%e7%82%b9-11)
      - [思路：](#%e6%80%9d%e8%b7%af-11)
      - [难点：](#%e9%9a%be%e7%82%b9-11)
      - [技巧：](#%e6%8a%80%e5%b7%a7-10)
      - [思考：](#%e6%80%9d%e8%80%83-10)
    - [T13. 调整数组顺序使奇数位于偶数前面（M21.P129）](#t13-%e8%b0%83%e6%95%b4%e6%95%b0%e7%bb%84%e9%a1%ba%e5%ba%8f%e4%bd%bf%e5%a5%87%e6%95%b0%e4%bd%8d%e4%ba%8e%e5%81%b6%e6%95%b0%e5%89%8d%e9%9d%a2m21p129)
      - [考点：](#%e8%80%83%e7%82%b9-12)
      - [思路：](#%e6%80%9d%e8%b7%af-12)
      - [难点：](#%e9%9a%be%e7%82%b9-12)
      - [技巧：](#%e6%8a%80%e5%b7%a7-11)
      - [思考：](#%e6%80%9d%e8%80%83-11)
  - [十. 代码的鲁棒性](#%e5%8d%81-%e4%bb%a3%e7%a0%81%e7%9a%84%e9%b2%81%e6%a3%92%e6%80%a7)
    - [T14. 链表中倒数第K个结点（M22.P134）](#t14-%e9%93%be%e8%a1%a8%e4%b8%ad%e5%80%92%e6%95%b0%e7%ac%ack%e4%b8%aa%e7%bb%93%e7%82%b9m22p134)
      - [考点：](#%e8%80%83%e7%82%b9-13)
      - [思路：](#%e6%80%9d%e8%b7%af-13)
      - [难点：](#%e9%9a%be%e7%82%b9-13)
      - [技巧：](#%e6%8a%80%e5%b7%a7-12)
      - [思考：](#%e6%80%9d%e8%80%83-12)
    - [T15. 反转链表（M24.P142）](#t15-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8m24p142)
      - [考点：](#%e8%80%83%e7%82%b9-14)
      - [思路：](#%e6%80%9d%e8%b7%af-14)
      - [难点：](#%e9%9a%be%e7%82%b9-14)
      - [技巧：](#%e6%8a%80%e5%b7%a7-13)
      - [思考：](#%e6%80%9d%e8%80%83-13)


# 剑指offer练习题

## 说明：
> * 这里的顺序是牛客网上的
> * 书上的顺序注在括号中
> * 每题尽量从：考点、思路、难点、技巧、思考几个维度分析，总结。
> * 测试在main函数zhong中，实现在下面函数中。

## 一. 数组
### T1. 二维数组中的查找（M4.P44）
> **题目描述**
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 考点：
> * 求一个二维数组的行数，列数
> * 剔除一个二维数组的某行，或某列: 
 --column;
 ++row;
> * 二维矩阵的角标从0开始

#### 思路：
> **方法一：暴力法O(n^2)**
> **方法二：边找边删除法**
> * 每次取数组固定位置：右上角的元素
> * 将其与目标数比较，相同输出，不同剔除一行或者一列
> * 重复1-2直到找到元素或遍历完整个数组
        
#### 难点：
> * 将找不到目标时查右，下元素（有重叠元素）转化为找右或下
> * boolean类型的函数，设置状态变量：boolean found = false;
> *  二维数组“假”删除某行或者某列
 --column;
 ++row;
> * 二维数组不为空的判定条件：matrix != null && rows > 0 && columns > 0

#### 技巧：
> * 用row,column的变化，依次剔除不符合条件的行列，而没用真正用一个临时二维数组存每次剔除完行列的新数组。
#### 代码实现：
```java
/*题目描述:
    在一个二维数组中（每个一维数组的长度相同），
每一行都按照从左到右递增的顺序排序，
每一列都按照从上到下递增的顺序排序。
    请完成一个函数，
输入这样的一个二维数组和一个整数，
判断数组中是否含有该整数。 
*/
class T1ArraySearch {

    public static void main(String[] args) {

        // 定义一个整型数组:3行4列
        int matrix[][] = new int[3][4];

        // 获取行数---3行
        int lenX = matrix.length; // 3
        // 获取列数---4列
        int lenY = matrix[0].length; // 4

        System.out.println("\nlenX = " + lenX + "  lenY = " + lenY + '\n');

        int num = 0;
        for (int x = 0; x < lenX; x++) {
            for (int y = 0; y < lenY; y++) {
                matrix[x][y] = num++;
            }
        }

        for (int x = 0; x < lenX; x++) {
            for (int y = 0; y < lenY; y++) {
                System.out.print(matrix[x][y] + " ");
            }
            System.out.println();
        }
        // test
        boolean a = Find(5,matrix);
        System.out.println(a);  

    }

    public static boolean Find(int target, int[][] matrix) {
        /*思路：
        1、 每次取数组固定位置：右上角的元素
        2、将其与目标数比较，相同输出，不同剔除一行或者一列
        3、重复1-2直到找到元素或遍历完整个数组
        */
        boolean found = false;
        // 获取行数---3行
        int rows = matrix.length;
        // 获取列数---4列
        int columns = matrix[0].length;

        if (matrix != null && rows > 0 && columns > 0) {// 二维矩阵不为空
            // 右上角的元素坐标：row,column
            int row = 0;
            int column = columns - 1;
            while (row < rows && column >= 0) {
                // 还没遍历完时
                if (matrix[row][column] == target) {
                    // 右上角和target正好相等就结束寻找
                    found = true;
                    return found;
                    // break;
                } else if (matrix[row][column] > target) {
                    // 右上角>target,剔除matrix最后一列
                    --column;
                } else {
                    // 右上角<target,剔除matrix上面一行
                    ++row;
                }
            }
            found =  false;
            return found;

        }
        System.out.println("matrix is wrong!");
        found =  false;
        return found;
    }
}
```


## 二. 字符串
### T2. 替换空格（M5.P51）
> **题目描述**
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 考点：
> * java中字符串,尾部没有"\0"
> * java 字符串的常用方法 https://www.runoob.com/java/java-stringbuffer.html
> * String类：创建后不可修改,适用于少量的字符串操作的情况
> * StringBuffer & StringBuilder 类
> **相同点：**
> 其对象能够被多次的修改，并且不产生新的未使用对象。
> **不同点：**
> 1. StringBuilder（常用）的方法不是线程安全的（不能同步访问），但速度快,
>    适用于单线程下在字符缓冲区进行大量操作的情况
> 2. StringBuffer线程安全的，但是慢,适用多线程下在字符缓冲区进行大量操作的情况
> 3. 强调速度：用StringBuilder，有线程隐患：用StringBuffer

#### 思路：
> 1. 看清要求：在原始字符串上操作还是可以使用新的中介变量
> 2. 方案一：原始字符串上操作，且尾部有足够的空间
> * 从前往后替换：思路简单易懂，但是要多次移动，效率低。
> * 从后往前替换：要先计算需要增加多少，但是效率高。
> 3. 方案二：可以使用中间变量存一下

#### 难点：
> 1. 判断StringBuffer型字符串中是否有空格
> * 返回字符串序列中指定索引处的 char 值，记作temp
> * char类型可以直接跟int类型进行比较.
> * char类型的空格换成int是32.
> 2. 计算完替换完的长度，一定要设置其长度为newLength，虽然newLength仍然小于str.capacity()，但是容量没用完的地方可能啥都有，必须清空给新元素用
``` java
        int length = str.length();          // 返回长度：所含字符个数。:13
        int originalLength= str.capacity(); // 返回当前容量: 字符串实际大小:29
        int newLength = 0;    
        newLength = length + 2*numBlack; // 17,每出现一个空格，字符串替换之后长度增加2
        str.setLength(newLength);   // 原来放teng13个元素，现在要放17个，必须腾出来
```

![StringBuilderlength capacity方法区别](image/T2_StringBuffer&#32;length和capacity方法的区别.png)

#### 技巧:
> 1. '++','--'的应用
``` java 
        // 定义index指向原始字符串的末尾和替换之后的字符串的末尾，从后往前替换
        while(originalIndex>=0){
            if(str.charAt(originalIndex) == ' '){
                str.setCharAt(newIndex--, '0');
                str.setCharAt(newIndex--, '2');
                str.setCharAt(newIndex--, '%');
            }
            else{
                str.setCharAt(newIndex--, str.charAt(originalIndex));
            }
            --originalIndex ; 
        }
```
> 2. 牛客网加了这部分判断报错：只能通过50%case，注释掉
``` java
        // 牛客网加了这部分判断报错：只能通过50%case，注释掉
        if(str == null || length==0){ 
          // str为空为非法输入
            String message = "wrong input";
            return message;
        }
        // 牛客网加了这部分判断报错：只能通过50%case，注释掉
        if (newLength > originalLength){
          // 替换后长度超出容量，报错
            String message = "wrong input";
            return message;
        }
```
#### 思考：
> 1. 掌握常见类及其常见方法，可以节省很多无用功
> 2. 注意不同类型之间的运算，如比较（str.charAt(originalIndex) == ' '），如函数要求返回值为String,就要符合要求的返回，（result = str.toString();）

## 三. 链表
### T3. 二维数组中的查找（M6.P58）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：


## 四. 树
### T4. 重建二叉树（M7.P62）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

## 五. 栈和队列
### T5. 用两个栈实现队列（M9.P68）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

## 六. 查找和排序
### T6. 旋转数组的最小数字（M11.P82）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

## 七. 递归和循环
### T7. 斐波拉切数列（M10.P74）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T8. 跳台阶（M10.P74）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T9. 变态跳台阶（M10.P74）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T10. 矩形覆盖（M10.P74）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：


## 八. 位运算
### T11. 二进制中1的个数（M15.P100）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：


## 九. 代码的完整性
### T12. 数值的整数次方（M16.P110）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T13. 调整数组顺序使奇数位于偶数前面（M21.P129）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：


## 十. 代码的鲁棒性
### T14. 链表中倒数第K个结点（M22.P134）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T15. 反转链表（M24.P142）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：
