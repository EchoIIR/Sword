
- [剑指offer练习题](#%e5%89%91%e6%8c%87offer%e7%bb%83%e4%b9%a0%e9%a2%98)
  - [说明：](#%e8%af%b4%e6%98%8e)
  - [一. 数组](#%e4%b8%80-%e6%95%b0%e7%bb%84)
    - [T1. 二维数组中的查找（M4.P44）](#t1-%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9f%a5%e6%89%bem4p44)
      - [考点：](#%e8%80%83%e7%82%b9)
      - [思路：](#%e6%80%9d%e8%b7%af)
      - [难点：](#%e9%9a%be%e7%82%b9)
      - [技巧：](#%e6%8a%80%e5%b7%a7)
      - [代码实现：](#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0)
  - [二. 字符串](#%e4%ba%8c-%e5%ad%97%e7%ac%a6%e4%b8%b2)
    - [T2. 替换空格（M5.P51）](#t2-%e6%9b%bf%e6%8d%a2%e7%a9%ba%e6%a0%bcm5p51)
      - [考点：](#%e8%80%83%e7%82%b9-1)
      - [思路：](#%e6%80%9d%e8%b7%af-1)
      - [难点：](#%e9%9a%be%e7%82%b9-1)
      - [技巧:](#%e6%8a%80%e5%b7%a7)
      - [思考：](#%e6%80%9d%e8%80%83)
      - [代码实现：](#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1)
  - [三. 链表](#%e4%b8%89-%e9%93%be%e8%a1%a8)
    - [T3. 二维数组中的查找（M6.P58）](#t3-%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9f%a5%e6%89%bem6p58)
      - [考点：](#%e8%80%83%e7%82%b9-2)
      - [思路：](#%e6%80%9d%e8%b7%af-2)
      - [难点：](#%e9%9a%be%e7%82%b9-2)
      - [技巧：](#%e6%8a%80%e5%b7%a7-1)
      - [思考：](#%e6%80%9d%e8%80%83-1)
  - [四. 树](#%e5%9b%9b-%e6%a0%91)
    - [T4. 重建二叉树（M7.P62）](#t4-%e9%87%8d%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91m7p62)
      - [考点：](#%e8%80%83%e7%82%b9-3)
      - [思路：](#%e6%80%9d%e8%b7%af-3)
      - [难点：](#%e9%9a%be%e7%82%b9-3)
      - [技巧：](#%e6%8a%80%e5%b7%a7-2)
      - [思考：](#%e6%80%9d%e8%80%83-2)
  - [五. 栈和队列](#%e4%ba%94-%e6%a0%88%e5%92%8c%e9%98%9f%e5%88%97)
    - [T5. 用两个栈实现队列（M9.P68）](#t5-%e7%94%a8%e4%b8%a4%e4%b8%aa%e6%a0%88%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97m9p68)
      - [考点：](#%e8%80%83%e7%82%b9-4)
      - [思路：](#%e6%80%9d%e8%b7%af-4)
  - [六. 查找和排序](#%e5%85%ad-%e6%9f%a5%e6%89%be%e5%92%8c%e6%8e%92%e5%ba%8f)
    - [T6. 旋转数组的最小数字（M11.P82）](#t6-%e6%97%8b%e8%bd%ac%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%b0%8f%e6%95%b0%e5%ad%97m11p82)
      - [考点：](#%e8%80%83%e7%82%b9-5)
      - [思考与思路：](#%e6%80%9d%e8%80%83%e4%b8%8e%e6%80%9d%e8%b7%af)
      - [技巧：](#%e6%8a%80%e5%b7%a7-3)
      - [代码清单：](#%e4%bb%a3%e7%a0%81%e6%b8%85%e5%8d%95)
  - [七. 递归和循环](#%e4%b8%83-%e9%80%92%e5%bd%92%e5%92%8c%e5%be%aa%e7%8e%af)
    - [T7. 斐波拉切数列（M10.P74）](#t7-%e6%96%90%e6%b3%a2%e6%8b%89%e5%88%87%e6%95%b0%e5%88%97m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-6)
      - [思路：](#%e6%80%9d%e8%b7%af-5)
      - [难点：](#%e9%9a%be%e7%82%b9-4)
      - [技巧：](#%e6%8a%80%e5%b7%a7-4)
      - [思考：](#%e6%80%9d%e8%80%83-3)
    - [T8. 跳台阶（M10.P74）](#t8-%e8%b7%b3%e5%8f%b0%e9%98%b6m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-7)
      - [思路：](#%e6%80%9d%e8%b7%af-6)
      - [难点：](#%e9%9a%be%e7%82%b9-5)
      - [技巧：](#%e6%8a%80%e5%b7%a7-5)
      - [思考：](#%e6%80%9d%e8%80%83-4)
    - [T9. 变态跳台阶（M10.P74）](#t9-%e5%8f%98%e6%80%81%e8%b7%b3%e5%8f%b0%e9%98%b6m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-8)
      - [思路：](#%e6%80%9d%e8%b7%af-7)
      - [难点：](#%e9%9a%be%e7%82%b9-6)
      - [技巧：](#%e6%8a%80%e5%b7%a7-6)
      - [思考：](#%e6%80%9d%e8%80%83-5)
    - [T10. 矩形覆盖（M10.P74）](#t10-%e7%9f%a9%e5%bd%a2%e8%a6%86%e7%9b%96m10p74)
      - [考点：](#%e8%80%83%e7%82%b9-9)
      - [思路：](#%e6%80%9d%e8%b7%af-8)
      - [难点：](#%e9%9a%be%e7%82%b9-7)
      - [技巧：](#%e6%8a%80%e5%b7%a7-7)
      - [思考：](#%e6%80%9d%e8%80%83-6)
  - [八. 位运算](#%e5%85%ab-%e4%bd%8d%e8%bf%90%e7%ae%97)
    - [T11. 二进制中1的个数（M15.P100）](#t11-%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%b8%ad1%e7%9a%84%e4%b8%aa%e6%95%b0m15p100)
      - [考点：](#%e8%80%83%e7%82%b9-10)
      - [代码清单：](#%e4%bb%a3%e7%a0%81%e6%b8%85%e5%8d%95-1)
  - [九. 代码的完整性](#%e4%b9%9d-%e4%bb%a3%e7%a0%81%e7%9a%84%e5%ae%8c%e6%95%b4%e6%80%a7)
    - [T12. 数值的整数次方（M16.P110）](#t12-%e6%95%b0%e5%80%bc%e7%9a%84%e6%95%b4%e6%95%b0%e6%ac%a1%e6%96%b9m16p110)
      - [考点：](#%e8%80%83%e7%82%b9-11)
      - [思路：](#%e6%80%9d%e8%b7%af-9)
      - [代码清单：](#%e4%bb%a3%e7%a0%81%e6%b8%85%e5%8d%95-2)
    - [T13. 调整数组顺序使奇数位于偶数前面（M21.P129）](#t13-%e8%b0%83%e6%95%b4%e6%95%b0%e7%bb%84%e9%a1%ba%e5%ba%8f%e4%bd%bf%e5%a5%87%e6%95%b0%e4%bd%8d%e4%ba%8e%e5%81%b6%e6%95%b0%e5%89%8d%e9%9d%a2m21p129)
      - [考点：](#%e8%80%83%e7%82%b9-12)
      - [思路：](#%e6%80%9d%e8%b7%af-10)
      - [难点：](#%e9%9a%be%e7%82%b9-8)
      - [思考：](#%e6%80%9d%e8%80%83-7)
  - [十. 代码的鲁棒性](#%e5%8d%81-%e4%bb%a3%e7%a0%81%e7%9a%84%e9%b2%81%e6%a3%92%e6%80%a7)
    - [T14. 链表中倒数第K个结点（M22.P134）](#t14-%e9%93%be%e8%a1%a8%e4%b8%ad%e5%80%92%e6%95%b0%e7%ac%ack%e4%b8%aa%e7%bb%93%e7%82%b9m22p134)
      - [考点：](#%e8%80%83%e7%82%b9-13)
      - [思路：](#%e6%80%9d%e8%b7%af-11)
      - [难点：](#%e9%9a%be%e7%82%b9-9)
      - [技巧：](#%e6%8a%80%e5%b7%a7-8)
      - [思考：](#%e6%80%9d%e8%80%83-8)
    - [T15. 反转链表（M24.P142）](#t15-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8m24p142)
      - [考点：](#%e8%80%83%e7%82%b9-14)
      - [思路：](#%e6%80%9d%e8%b7%af-12)
      - [难点：](#%e9%9a%be%e7%82%b9-10)
      - [技巧：](#%e6%8a%80%e5%b7%a7-9)
      - [思考：](#%e6%80%9d%e8%80%83-9)


# 剑指offer练习题

## 说明：
> * 这里的顺序是牛客网上的
> * 书上的顺序注在括号中
> * 每题尽量从：考点、思路、难点、技巧、思考几个维度分析，总结。
> * 测试在main函数zhong中，实现在下面函数中。

## 一. 数组
### T1. 二维数组中的查找（M4.P44）
> **题目描述**
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 考点：
> * 求一个二维数组的行数，列数
> * 剔除一个二维数组的某行，或某列: 
 --column;
 ++row;
> * 二维矩阵的角标从0开始

#### 思路：
> **方法一：暴力法O(n^2)**
> **方法二：边找边删除法**
> * 每次取数组固定位置：右上角的元素
> * 将其与目标数比较，相同输出，不同剔除一行或者一列
> * 重复1-2直到找到元素或遍历完整个数组
        
#### 难点：
> * 将找不到目标时查右，下元素（有重叠元素）转化为找右或下
> * boolean类型的函数，设置状态变量：boolean found = false;
> *  二维数组“假”删除某行或者某列
 --column;
 ++row;
> * 二维数组不为空的判定条件：matrix != null && rows > 0 && columns > 0

#### 技巧：
> * 用row,column的变化，依次剔除不符合条件的行列，而没用真正用一个临时二维数组存每次剔除完行列的新数组。
#### 代码实现：
```java
/*题目描述:
    在一个二维数组中（每个一维数组的长度相同），
每一行都按照从左到右递增的顺序排序，
每一列都按照从上到下递增的顺序排序。
    请完成一个函数，
输入这样的一个二维数组和一个整数，
判断数组中是否含有该整数。 
*/
class T1ArraySearch {

    public static void main(String[] args) {

        // 定义一个整型数组:3行4列
        int matrix[][] = new int[3][4];

        // 获取行数---3行
        int lenX = matrix.length; // 3
        // 获取列数---4列
        int lenY = matrix[0].length; // 4

        System.out.println("\nlenX = " + lenX + "  lenY = " + lenY + '\n');

        int num = 0;
        for (int x = 0; x < lenX; x++) {
            for (int y = 0; y < lenY; y++) {
                matrix[x][y] = num++;
            }
        }

        for (int x = 0; x < lenX; x++) {
            for (int y = 0; y < lenY; y++) {
                System.out.print(matrix[x][y] + " ");
            }
            System.out.println();
        }
        // test
        boolean a = Find(5,matrix);
        System.out.println(a);  

    }

    public static boolean Find(int target, int[][] matrix) {
        /*思路：
        1、 每次取数组固定位置：右上角的元素
        2、将其与目标数比较，相同输出，不同剔除一行或者一列
        3、重复1-2直到找到元素或遍历完整个数组
        */
        boolean found = false;
        // 获取行数---3行
        int rows = matrix.length;
        // 获取列数---4列
        int columns = matrix[0].length;

        if (matrix != null && rows > 0 && columns > 0) {// 二维矩阵不为空
            // 右上角的元素坐标：row,column
            int row = 0;
            int column = columns - 1;
            while (row < rows && column >= 0) {
                // 还没遍历完时
                if (matrix[row][column] == target) {
                    // 右上角和target正好相等就结束寻找
                    found = true;
                    return found;
                    // break;
                } else if (matrix[row][column] > target) {
                    // 右上角>target,剔除matrix最后一列
                    --column;
                } else {
                    // 右上角<target,剔除matrix上面一行
                    ++row;
                }
            }
            found =  false;
            return found;

        }
        System.out.println("matrix is wrong!");
        found =  false;
        return found;
    }
}
```


## 二. 字符串
### T2. 替换空格（M5.P51）
> **题目描述**
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 考点：
> 1. java中字符串,尾部没有"\0"
> 2. java 字符串的常用方法 https://www.runoob.com/java/java-stringbuffer.html
> 3. String类：创建后不可修改,适用于少量的字符串操作的情况
> 4. StringBuffer & StringBuilder 类
> * **相同点：**
> 其对象能够被多次的修改，并且不产生新的未使用对象。
> * **不同点：**
> (1). StringBuilder（常用）的方法不是线程安全的（不能同步访问），但速度快,适用于单线程下在字符缓冲区进行大量操作的情况
> (2). StringBuffer线程安全的，但是慢,适用多线程下在字符缓冲区进行大量操作的情况
> (3). 强调速度：用StringBuilder，有线程隐患：用StringBuffer

#### 思路：
> 1. 看清要求：在原始字符串上操作还是可以使用新的中介变量
> 2. 方案一：原始字符串上操作，且尾部有足够的空间
> * 从前往后替换：思路简单易懂，但是要多次移动，效率低。
> * 从后往前替换：要先计算需要增加多少，但是效率高。
> 3. 方案二：可以使用中间变量存一下

#### 难点：
> 1. 判断StringBuffer型字符串中是否有空格
> * 返回字符串序列中指定索引处的 char 值，记作temp
> * char类型可以直接跟int类型进行比较.
> * char类型的空格换成int是32.
> 2. 计算完替换完的长度，一定要设置其长度为newLength，虽然newLength仍然小于str.capacity()，但是容量没用完的地方可能啥都有，必须清空给新元素用
``` java
        int length = str.length();          // 返回长度：所含字符个数。:13
        int originalLength= str.capacity(); // 返回当前容量: 字符串实际大小:29
        int newLength = 0;    
        newLength = length + 2*numBlack; // 17,每出现一个空格，字符串替换之后长度增加2
        str.setLength(newLength);   // 原来放teng13个元素，现在要放17个，必须腾出来
```

![StringBuilderlength capacity方法区别](image/T2_StringBuffer&#32;length和capacity方法的区别.png)

#### 技巧:
> 1. '++','--'的应用
``` java 
        // 定义index指向原始字符串的末尾和替换之后的字符串的末尾，从后往前替换
        while(originalIndex>=0){
            if(str.charAt(originalIndex) == ' '){
                str.setCharAt(newIndex--, '0');
                str.setCharAt(newIndex--, '2');
                str.setCharAt(newIndex--, '%');
            }
            else{
                str.setCharAt(newIndex--, str.charAt(originalIndex));
            }
            --originalIndex ; 
        }
```
> 2. 牛客网加了这部分判断报错：只能通过50%case，注释掉
``` java
        // 牛客网加了这部分判断报错：只能通过50%case，注释掉
        if(str == null || length==0){ 
          // str为空为非法输入
            String message = "wrong input";
            return message;
        }
        // 牛客网加了这部分判断报错：只能通过50%case，注释掉
        if (newLength > originalLength){
          // 替换后长度超出容量，报错
            String message = "wrong input";
            return message;
        }
```
#### 思考：
> 1. 掌握常见类及其常见方法，可以节省很多无用功
> 2. 注意不同类型之间的运算，如比较（str.charAt(originalIndex) == ' '），如函数要求返回值为String,就要符合要求的返回，（result = str.toString();）

#### 代码实现：
```java
/*请实现一个函数:
将一个字符串中的每个空格替换成“%20”。
例如，当字符串为We Are Happy.
则经过替换之后的字符串为We%20Are%20Happy。
*/
class T2_ReplaceBlack{
    public static void main(String[] args) {
        StringBuffer str = new StringBuffer("We Are Happy.");
        System.out.println(replaceSpace(str));
        /* ======== test ===========
        for (int x=0; x<str.length();x++ ){
            System.out.print(str.charAt(x));
        }
        int length = str.length();          // 返回长度（字符数）:字符串的实际长度
        int originalLength= str.capacity(); // 返回当前容量: 字符串所占容器的总大小
        System.out.println("\nlength = " + length);
        System.out.println("originalLength = " + originalLength); 

        StringBuffer str2 = new StringBuffer(); // 默认长度是16
        System.out.println(str2.length());
        System.out.println(str2.capacity());
        */
    
    }
    /*
    
    */
    public static String replaceSpace(StringBuffer str) {
        /* 思路：
        1、 遍历字符串，确定空格数，从而算出新的str的大小
        2、 从后往前，依次替换空格为%20
        3、 返回结果
        */
        int length = str.length();          // 返回长度：所含字符个数。:13
        int originalLength= str.capacity(); // 返回当前容量: 字符串实际大小:29
        int newLength = 0;
        String result;
        // 牛客网加了这部分判断报错：只能通过50%case，注释掉
        if(str == null || length==0){
            String message = "wrong input";
            return message;
        }

        // 1.统计空格数量
        int numBlack = 0;
        for (int x=0; x<str.length(); x++){
            if (str.charAt(x) == ' '){
                //  char类型的空格换成int是32.//   char类型可以直接跟int类型进行比较.
                numBlack++;
            }
        }
        // 2. 计算新的字符串的长度
        newLength = length + 2*numBlack; // 17,每出现一个空格，字符串替换之后长度增加2
        // 牛客网加了这部分判断报错：只能通过50%case，注释掉
        if (newLength > originalLength){
            String message = "wrong input";
            return message;
        }
        System.out.println(str.length());
        str.setLength(newLength);   // 原来放teng13个元素，现在要放17个，必须腾出来
        System.out.println(str.length());       
        // 3. 定义index指向原始字符串的末尾和替换之后的字符串的末尾，从后往前替换
        int originalIndex = length-1 ;
        int newIndex = newLength-1;

        while(originalIndex>=0){
            if(str.charAt(originalIndex) == ' '){
                str.setCharAt(newIndex--, '0');
                str.setCharAt(newIndex--, '2');
                str.setCharAt(newIndex--, '%');
            }
            else{
                str.setCharAt(newIndex--, str.charAt(originalIndex));
            }
            --originalIndex ; 
        }
        result = str.toString();
        return result ;
    }
}
```

## 三. 链表
### T3. 二维数组中的查找（M6.P58）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：


## 四. 树
### T4. 重建二叉树（M7.P62）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

## 五. 栈和队列
### T5. 用两个栈实现队列（M9.P68）
> **题目要求：**
> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### 考点：
> **Java Stack 类**
> 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。
> **Java Stack 类自定义方法**
>> * boolean empty() :
>>       测试堆栈是否为空。
>> * Object peek( ):
>>        查看堆栈顶部的对象，但不从堆栈中移除它。
>> * Object pop( ):
>>       移除堆栈顶部的对象，并作为此函数的值返回该对象。
>> * Object push(Object element):
>>      把项压入堆栈顶部。
>> * int search(Object element):
>> 返回对象在堆栈中的位置，以 1 为基数。

>  **Java LinkedList类**
> 实现了Queue接口，因此我们可以把LinkedList当成Queue来用,下面是测试代码。
```java
import java.util.LinkedList;
import java.util.Queue;
 
public class Main {
    public static void main(String[] args) {
        //add()和remove()方法在失败的时候会抛出异常(不推荐)
        Queue<String> queue = new LinkedList<String>();
        //添加元素
        queue.offer("a");
        queue.offer("b");
        queue.offer("c");
        queue.offer("d");
        queue.offer("e");
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("poll="+queue.poll()); //返回第一个元素，并在队列中删除
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("element="+queue.element()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("peek="+queue.peek()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
    }
}
```
#### 思路：
> 如下图：
> 增：全放在stcak1中
> 删：先stcak1出到stcak2，再stcak2出。
![T5_StackAndQueue.png](image/T5_StackAndQueue.png)

## 六. 查找和排序
### T6. 旋转数组的最小数字（M11.P82）
> **题目描述**
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

#### 考点：
> 1. 有条件二分法的使用
> 2. 对于特殊测试用例的处理


#### 思考与思路：
> 1. 对于有序的数据查找，通常使用二分法
> 2. 旋转数组的特点是两部分数组均有序，且一个》另一个，要充分利用这些数据特点
> 

#### 技巧：
> 1. indexMid初始值的设定，可以使得旋转数组为有序数组的情况也可以轻松处理
> 2. 函数的返回值要注意类型：int型还是其他的，最好把各种情况都统一到一个值上面再返回，这样好管理
``` java 
indexMid = index1;    // 为了处理输入有序的数组的特例
```

#### 代码清单：
```  java 
class T6_FindMinInArray{
    /*
    题目描述
    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
    输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
    例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
    NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
    */
    public static void main(String[] args) {
        // 1. 排好序的数组，移动前若干个元素到末尾，生成旋转数组
        // 定义一个整型数组:3行4列
        //int [] numbers = {1,2,3,4,5};
        int [] rotateNumbers = {3,4,5,1,2,3};
        // 2. 输出旋转数组中的最小值
        int result = minNumberInRotateArray(rotateNumbers);
        System.out.println(result);
    }
    public static int minNumberInRotateArray(int [] array) {
        
        int result;
        int length = array.length;
        if(array == null || length<=0){
            System.out.println("Wrong input!");
            return -1;
        }

        int index1 = 0;
        int index2 = length-1;
        int indexMid = index1;

        while(array[index1] >= array[index2]){
            // indexMid指向最终结果
            // 条件不满足时，直接返回indexMid = index1;
            if(index2 - index1 == 1){   // 找到了
                indexMid = index2;
                break;  
            }
            indexMid = (index1 + index2)/2;
            if (array[indexMid] >= array[index1]){
                index1 = indexMid;
            }
            else{
                index2 = indexMid;
            }
        }

        result = array[indexMid];
        return result;
    }
}
```
## 七. 递归和循环
### T7. 斐波拉切数列（M10.P74）
> **题目描述**
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）,n<=39.

#### 考点：
> 1、Fibonacci数列：F(n)=F(n-1)+F(n-2)
> 2、递归


#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T8. 跳台阶（M10.P74）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T9. 变态跳台阶（M10.P74）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T10. 矩形覆盖（M10.P74）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：


## 八. 位运算
### T11. 二进制中1的个数（M15.P100）
> **题目描述**
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
#### 考点：
> 1、进制转换：参考JavaViedo中的练习：NumBaseConvert.java
#### 代码清单：
``` java
class T11_NumberOf1{
    public static void main(String[] args) {
        int num = 8;
        
        int count = NumberOf1(num);
        System.out.println("\n NumberOf1: " + count); 
    }


    public static int NumberOf1(int num){
      
        System.out.println("\n The num " + num + " trasfer using Table is :" ); 
        char[] table = {'0','1'};

        int base = 1;
        int offset = 1;
        char[] result = new char[32]; // 按占位最大的二进制来分，用32位存结果
        int pos = result.length;
        if (num == 0){
            System.out.println("0");
            return 0;
        }
        while (num != 0){
            int temp = num & base;        // 取数
            result[--pos] = table[temp]; 
            num = num>>>offset;
        }
       
        //System.out.println("\n result2"); 
        int count =0;
        for (int x=0; x<=result.length-1;x++){
            // 倒序打印数组元素
            // System.out.print(result[x]);
            if(result[x] == '1'){
                count++;
            }
        }
        return count;
    }
}
```



## 九. 代码的完整性
### T12. 数值的整数次方（M16.P110）
> 题目描述
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
#### 考点：
> 1、多重条件判断：if - else if - else
> 2、逻辑运算符的使用：
> 保证base和exponent不同时为0：
>  base != 0 || exponent != 0
#### 思路：
#### 代码清单：
```java
/*
题目描述
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
*/
class T12_Power {
    public static void main(String[] args) {
        double base = 2;
        int exponent = 3;
        double result = Power(base, exponent);
        System.out.println("result = " + result);
    }

    /* // ===== 自己实现绝对值 ==========
    public static double Power(double base, int exponent){
        double result = 1;
        if (base != 0 || exponent != 0){
                if(exponent>0) {
                    for(int i = 1; i<=exponent;i++ ){
                        result = result*base;
                    }
                    return result;
                }else if (exponent<0){
                    for(int i = 1; i<=-exponent;i++ ){
                        result = result*base;                      
                    } 
                    result = 1/result;
                    return result;
                }
                else {
                    result = 1;
                    return result;
                }
        }
        else{// base和exponent同时为0
            return 0;
        }
    }
    */
        //  ======== 用java的Math的Math.abs方法 =============
        public static double Power(double base, int exponent) {
        double result = 1;
        if (base != 0 || exponent != 0) {

            for (int i = 1; i <= Math.abs(exponent); i++) {
                result = result * base;
            }
            if (exponent > 0) {
                return result;
            } else if (exponent < 0) {
                result = 1 / result;
                return result;
            } else {
                result = 1;
                return result;
            }
        } else {// base和exponent同时为0
            return 0;
        }
    }
}

```

### T13. 调整数组顺序使奇数位于偶数前面（M21.P129）
> **题目描述**
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
#### 考点：
#### 思路：
> **不需要额外存储空间**
> * 基于排序算法思想：
>  1、核心操作：遍历元素，按某种规则分两组：类似于排序算法
>  2、题目要求：奇数和奇数，偶数和偶数之间的相对位置不变，即要稳定
>  3、综上，要找一个稳定的“排序”算法，改装一下即可,如下图所示，
> 即：冒泡、插入、归并,代码省略。
![排序算法总结](image/排序算法总结.png)
> * 基于数据本身的特点：
> 1、数据有奇数有偶数：奇数不用变，遇到偶数时，记录当前位置i，再往下找下一个奇数j（找完时还没找到奇数就停止，说明后面都是偶数），将奇数移到之前第一次发现偶数的位置i，同时将i开始及其之后到j之前的这些偶数后移（这样保证相对位置不变）
>
> **需要额外存储空间**
> 1、遍历数组，奇数存一个变量，偶数存一个变量
> 2、将奇数数组，偶数数组拼接即可。

#### 难点：
> 1、注意题目要求：保证奇数和奇数，偶数和偶数之间的相对位置不变，即稳定，则下面的算法(仿照T2：空格替换思想)是不稳定的：
```java
    public static void reOrderArray(int [] array) {
        int length = array.length;
        int [] result = new int [length];
        int oddIndex = 0;
        int evenIndex = length-1;
        int num = 0;
        // 遍历数组，定义两个指针，一个指最开始，一个指最后
        for(int i=0; i<length;i++ ){
            num = array[i];
            if (num%2 != 0){// 奇数
                result[oddIndex] = num;
                oddIndex++;
            }else{
                result[evenIndex] = num;
                evenIndex--;
            }
        }
        // int newScores[] = (int[]) scores.clone();
        //array = result;

        array = result.clone();

        for(int i = 0; i< result.length; i++){
            System.out.println(result[i]); 
        }

    } 
```
> 2、移动第一个偶数开始到第一个奇数之间的这些偶数时，从后往前移动，就不会覆盖。
```java
                // 找到了就交换array[i]，array[j],并将i+1~j-1之间的偶数往后移动
                int tmp = array[i];
                array[i] = array[j];
                int count = j-i;
                while(count>1){//从后往前移动，最前面的在循环外移动
                    array[i + count] = array[i + count - 1];
                    count--;
                }
                array[i+1] = tmp;

```

#### 思考：
> 1、注意循环的边界条件，以及设置好变量，不要死循环
> 2、对于数组、栈等存放数据的容器，要注意特殊的情况，上来先判断是否为空，再进行后续操作。

## 十. 代码的鲁棒性
### T14. 链表中倒数第K个结点（M22.P134）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：

### T15. 反转链表（M24.P142）
#### 考点：
#### 思路：
#### 难点：
#### 技巧：
#### 思考：
